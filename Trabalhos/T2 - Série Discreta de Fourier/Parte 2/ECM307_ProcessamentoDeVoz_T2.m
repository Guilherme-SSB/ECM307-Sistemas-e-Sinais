%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Guilherme Samuel de Souza Barbosa%%  RA: 19.00012-0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  0 - Proposta %% %%  a. Cada aluno determina as frequências f0, f1 e f2 da sua própria gravação (3x) - cada vogal gera 9 valores => 45 valores no total%%  b. Formar base de conhecimento Número de alunos x 45%%  c. Histograma de cada vogal - média e o desvio padrão de cada frequência para cada vogal (espera-se distribuição gaussiana)%%  d. Eliminar valores fora de contexto e verificar diferenças da base - Tratamento dos Outliers%%  e. Gravar 5 vogais que não serão usadas na base (vogais_teste)%%  f. 1 - Acertou e 0 - Errou -> a, e, i, o, u%%  Ou seja, modelo de ML gera um vetor [1 1 0 0 1]: acertou /a/, /e/ e /u/ e errou /i/ e /o/%%  g. Verificar qualidade do sistema de aprendizado para cada vogal%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  1 - Preparação do código %% %%  Boas práticas: limpeza de variáveis; variáveis globais%%  Constantes; carregar bibliotecas;...%%%%% Limpezaclc;          % limpa visual da tela de comandosclose all;    % limpa as figurasclear all;    % limpa as variáveisdisp('1 - Preparando o código ...')%%% Omite mensagens de warningwarning('off')   % Não mostra eventos de warning%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  2 - Problema%% %%  Sinal g[k] - Sinal amostrado%%%%% Importação dos Sinaisdisp('2 - Importando os sinais das vogais ...')[gk, fs] = audioread('e/e1.wav');                                   % gk ← vetor do sinal amostrado                                 % fs ← frequência de amostragemgk = reshape(gk, [], 1);gk = gk(1:length(gk)/2);                                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  3 - Pré - processamento do sinal%%  %%  X[n] = 1/N sum_{k=0}^{N-1} g(k) exp(-j*n*k*2*pi/N)%%disp('3 - Extraindo informações do sinal ...')N                 = length(gk);                      % Número de pontos do vetor  Ts                = 1/fs;                            % Intervalo de amostragemDuracao_Sinal     = N*Ts;                            % Duração do sinal em segundostempo             = linspace(0, Duracao_Sinal, N);   % Vetor tempofmax              = fs/2;                            % Frequência máxima, respeitando Teorema da Amostragemfrequencia        = linspace(-fmax, +fmax, N);       % Vetor de frequência de N pontosTo                = tempo(2)-tempo(1);fprintf('\nO sinal tem duração de %.3f segundos\n\n', Duracao_Sinal)figure(1)plot(tempo, gk)     xlabel('Tempo em segundos')           ylabel('Amplitude')                  title('Sinal g(k) amostrado')    grid%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  4 - Janelamento%%%%Janelado = gk.*hanning(N);figure(2)plot(tempo, Janelado)xlabel('Tempo em segundos')           ylabel('Amplitude')                  title('Sinal g(k) janelado')    grid%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  5 - Fourier%%  %%  X[n] =  exp(-1i*2*pi/N)*ones(N, N).^([0:1:N-1]'*[0:1:N-1]) -> Produto Matricial%%disp('4 - Calculando a série de Fourier do sinal por produto matricial ...')tic;                                                   % inicia o contadorwn                = exp(-1i*2*pi/N);                   % Definindo wnMatriz_jotas      = wn*ones(N, N);                     % Cria a matriz de coeficientesMatriz_expoentes  = [0:1:N-1]'*[0:1:N-1];              % Matriz dos expoentes          Wn                = Matriz_jotas.^Matriz_expoentes;    % Matriz de Fourier - constante para N fixo%Xn  = Wn * gk;                                         % Série discreta de FourierXn  = Wn * Janelado;                                   % Série discreta de Fouriertoc;                                                   % termina o contadorfigure(3)plot(frequencia, fftshift(log10(abs(Xn))), 'k-', 'linewidth', 2)xlabel('Frequência em Hertz')           ylabel('Amplitude')                  title('Espectro de Amplitudes - Entrada')    grid%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  6 - Filtragem do ruído %%%%Ganho = @(w, R, C) 1./(1i*w*R*C + 1);R = 1;C = 1;filtrado = Ganho(2*pi*fs, R, C).*Xn;%figure(4)%plot(frequencia, fftshift(log10(abs(filtrado))), 'k-', 'linewidth', 2)%xlabel('Frequência em Hertz')           %ylabel('Amplitude')                  %title('Espectro de Amplitudes - Filtrado')    %grid%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  7 - Encontrar f0, f1, f2%%  %%  https://octave.sourceforge.io/signal/function/findpeaks.html%%data = fftshift(log10(abs(Xn)));valor = frequencia(2) - frequencia(1);[pks,locs] = findpeaks(data, frequencia, "MinPeakDistance", valor);pks_positivos = double.empty;locs_positivos = double.empty;for i=1:length(locs)    if locs(i) > 0        pks_positivos(end+1) = pks(i);        locs_positivos(end+1) = locs(i);    end   end[y, x] = findpeaks(pks_positivos, locs_positivos, "MinPeakDistance", valor);[y_new, x_new] = findpeaks(y, x, "MinPeakDistance", 80*valor);figure(4)findpeaks(y, x, "MinPeakDistance", 80*valor);vetor_f = x_new;%fprintf('\nO valor de f0 é %.2f \n', vetor_f(1))%fprintf('\nO valor de f1 é %.2f \n', vetor_f(2))%fprintf('\nO valor de f2 é %.2f \n', vetor_f(3))%fprintf('\nO valor de f3 é %.2f \n', vetor_f(4))%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  8 - Trabalhando com os dados gerados%%%%Dados = readtable('Dados.xlsx','PreserveVariableNames',true);  % Espera-se que 'Dados.xlsx' tenha colunas:  f0, f1, f2, Vogal ,Voz, Nome, RA  sum(ismissing(Dados))   % Verifica se há dados faltantesDados = Dados(:, 1:5);  % Exclui as colunas 'Nome' e 'RA'vogal = Dados.Vogal;f0    = Dados.f0;f1    = Dados.f1;f2    = Dados.f2;voz   = Dados.Voz;%% Separando os dados por vogala = strings;e = strings;i = strings;o = strings;u = strings;for k=1:length(vogal)    if ismember(vogal(k), 'a')        a(k) = cell2mat(vogal(k));    elseif ismember(vogal(k), 'e')        e(k) = cell2mat(vogal(k));          elseif ismember(vogal(k), 'i')        i(k) = cell2mat(vogal(k));    elseif ismember(vogal(k), 'o')        o(k) = cell2mat(vogal(k));            elseif ismember(vogal(k), 'u')        u(k) = cell2mat(vogal(k));            else disp('\nVogal Inválida')    endendNa = length(a);a = double.empty;a = Dados(1:Na, 1:3);Ne = length(e);e = double.empty;e = Dados(Na+1:Ne, 1:3);Ni = length(i);i = double.empty;i = Dados(Ne+1:Ni, 1:3);No = length(o);o = double.empty;o = Dados(Ni+1:No, 1:3);Nu = length(u);u = double.empty;u = Dados(No+1:Nu, 1:3);%% Escolha da vogal de análiseANALISE_A = true;ANALISE_E = false;ANALISE_I = false;ANALISE_O = false;ANALISE_U = false;%% Gráfico de dispersão dos valores originaisf1_A = table2array(a(:,2));f2_A = table2array(a(:,3));f1_E = table2array(e(:,2));f2_E = table2array(e(:,3));f1_I = table2array(i(:,2));f2_I = table2array(i(:,3));f1_O = table2array(o(:,2));f2_O = table2array(o(:,3));f1_U = table2array(u(:,2));f2_U = table2array(u(:,3));figure(5)scatter(f1_A, f2_A)hold onscatter(f1_E, f2_E)hold onscatter(f1_I, f2_I)hold onscatter(f1_O, f2_O)hold onscatter(f1_U, f2_U)hold ontitle('Dispersão de f1 e f2 para cada vogal')legend('Vogal /a/', 'Vogal /e/', 'Vogal /i/', 'Vogal /o/', 'Vogal /u/')%%  Histograma da vogal de análise%%% f1figure(6)if (ANALISE_A == 1)    histogram(f1_A, round(sqrt(length(f1_A))))elseif (ANALISE_E == 1)    histogram(f1_E, round(sqrt(length(f1_E))))elseif (ANALISE_I == 1)    histogram(f1_I, round(sqrt(length(f1_I))))elseif (ANALISE_O == 1)    histogram(f1_O, round(sqrt(length(f1_O))))else (ANALISE_U);    histogram(f1_U, round(sqrt(length(f1_U))))endxlabel('Eixo x')ylabel('Eixo y')title('Histograma de f1 da vogal escolhida')grid%%% f2figure(7)if (ANALISE_A == 1)    histogram(f2_A, round(sqrt(length(f2_A))))elseif (ANALISE_E == 1)    histogram(f2_E, round(sqrt(length(f2_E))))elseif (ANALISE_I == 1)    histogram(f2_I, round(sqrt(length(f2_I))))elseif (ANALISE_O == 1)    histogram(f2_O, round(sqrt(length(f2_O))))else (ANALISE_U);    histogram(f2_U, round(sqrt(length(f2_U))))endxlabel('Eixo x')ylabel('Eixo y')title('Histograma de f2 da vogal escolhida')grid%%  Plotando o box plot de análiseif (ANALISE_A == 1)   A = [f1_A; f2_A];   g = [ones(size(f1_A)); 2*ones(size(f2_A))];elseif (ANALISE_E == 1)   A = [f1_E; f2_E];   g = [ones(size(f1_E)); 2*ones(size(f2_E))];elseif (ANALISE_I == 1)   A = [f1_I; f2_I];   g = [ones(size(f1_I)); 2*ones(size(f2_I))];elseif (ANALISE_O == 1)   A = [f1_O; f2_O];    g = [ones(size(f1_O)); 2*ones(size(f2_O))];else (ANALISE_O);   A = [f1_U; f2_U];   g = [ones(size(f1_U)); 2*ones(size(f2_U))];endfigure(8)boxplot(A, g);set(gca,'XTickLabel',{'f1','f2'})title('Box Plot da vogal escolhida')grid%%  Determinando média e desvio padrão de cada frequência de cada vogal%%mean()%%std()%% Tratamento dos Outliers%% rmoutliers(vogal, 'quartiles');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  10 - Modelo de decisão%%%%%% Feature Scaling -> Standardisation: Resultado estará entre -3 e +3Dados_freq = table2array(Dados(:, 1:3));Dados_freq(:,1) = (Dados_freq(:,1)-mean(Dados_freq(:,1))/std(Dados_freq(:,1)));Dados_freq(:,2) = (Dados_freq(:,2)-mean(Dados_freq(:,2))/std(Dados_freq(:,2)));Dados_freq(:,3) = (Dados_freq(:,3)-mean(Dados_freq(:,3))/std(Dados_freq(:,3)));%% Dividindo em clusterings utilizando o algoritmo k-means clusteringidx = kmeans(Dados_freq, 5);figure(9)gscatter(Dados_freq(:,2), Dados_freq(:,3), idx)legend('Vogal /a/', 'Vogal /e/', 'Vogal /i/', 'Vogal /o/', 'Vogal /u/')grid%% Treinando o modelomodelformed = fitcknn(Dados, 'Vogal~f1+f2');modelformed.NumNeighbors=10;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  11 - Verificação do modelo%%%%  predict(modelformed, [f1, f2])